diff --git a/BUGS b/BUGS
old mode 100644
new mode 100755
diff --git a/LICENSE b/LICENSE
old mode 100644
new mode 100755
diff --git a/Makefile b/Makefile
old mode 100644
new mode 100755
index 09d790c..9e72ab1
--- a/Makefile
+++ b/Makefile
@@ -70,6 +70,9 @@ QEMU = $(shell if which qemu > /dev/null; \
 	echo "*** or have you tried setting the QEMU variable in Makefile?" 1>&2; \
 	echo "***" 1>&2; exit 1)
 endif
+ifndef SCHEDFLAG
+SCHEDFLAG := DEFAULT
+endif
 
 CC = $(TOOLPREFIX)gcc
 AS = $(TOOLPREFIX)gas
@@ -78,6 +81,7 @@ OBJCOPY = $(TOOLPREFIX)objcopy
 OBJDUMP = $(TOOLPREFIX)objdump
 CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
 CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+CFLAGS += -D $(SCHEDFLAG)
 ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
 # FreeBSD ld wants ``elf_i386_fbsd''
 LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
@@ -181,6 +185,9 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+	_testing\
+	_sanity\
+	_SMLsanity\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -248,8 +255,9 @@ qemu-nox-gdb: fs.img xv6.img .gdbinit
 # check in that version.
 
 EXTRA=\
-	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c sanity.c SMLsanity.c\
 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	testing.c\
 	printf.c umalloc.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
diff --git a/Notes b/Notes
old mode 100644
new mode 100755
diff --git a/README b/README
old mode 100644
new mode 100755
diff --git a/SMLsanity.c b/SMLsanity.c
new file mode 100755
index 0000000..d3e8ef5
--- /dev/null
+++ b/SMLsanity.c
@@ -0,0 +1,88 @@
+#include "types.h"
+#include "user.h"
+
+int fact(int a){
+	if(a<=3)return 1;
+	return fact(a-1)*fact(a-2)*fact(a-3);
+}
+
+int main(int argc, char *argv[])
+{
+	if (argc != 2){
+				printf(1, "Usage: SMLsanity <n>\n");
+				exit();
+ 		}
+	int i;
+	int n;
+	int j = 0;
+	int k;
+	int retime;
+	int rutime;
+	int stime;
+	int sums[3][3];
+	for (i = 0; i < 3; i++)
+		for (j = 0; j < 3; j++)
+			sums[i][j] = 0;
+	n = atoi(argv[1]);
+	i = n; //unimportant
+	int pid;
+	for (i = 0; i < 3 * n; i++) {
+		j = i % 3;
+		pid = fork();
+		if (pid == 0) {//child
+			j = (getpid() - 4) % 3; // ensures independence from the first son's pid when gathering the results in the second part of the program
+			#ifdef SML
+			switch(j) {
+				case 0:
+          set_prio(3);
+					break;
+				case 1:
+          set_prio(2);
+					break;
+				case 2:
+          set_prio(1);
+					break;
+			}
+			#endif
+			
+      for (k = 0; k < 100; k++){
+        for (j = 0; j < 1000000; j++){
+			fact(3);
+		}
+      }
+			exit(); // children exit here
+		}
+		continue; // father continues to spawn the next child
+	}
+	for (i = 0; i < 3 * n; i++) {
+		pid = wait2(&retime, &rutime, &stime);
+		int res = (pid - 4) % 3; // correlates to j in the dispatching loop
+		switch(res) {
+			case 0: // CPU bound processes
+				printf(1, "Priority 3, pid: %d, ready: %d, running: %d, sleeping: %d, turnaround: %d\n", pid, retime, rutime, stime, retime + rutime + stime);
+				sums[0][0] += retime;
+				sums[0][1] += rutime;
+				sums[0][2] += stime;
+				break;
+			case 1: // CPU bound processes, short tasks
+				printf(1, "Priority 2, pid: %d, ready: %d, running: %d, sleeping: %d, turnaround: %d\n", pid, retime, rutime, stime, retime + rutime + stime);
+				sums[1][0] += retime;
+				sums[1][1] += rutime;
+				sums[1][2] += stime;
+				break;
+			case 2: // simulating I/O bound processes
+				printf(1, "Priority 1, pid: %d, ready: %d, running: %d, sleeping: %d, turnaround: %d\n", pid, retime, rutime, stime, retime + rutime + stime);
+				sums[2][0] += retime;
+				sums[2][1] += rutime;
+				sums[2][2] += stime;
+				break;
+		}
+	}
+	for (i = 0; i < 3; i++)
+		for (j = 0; j < 3; j++)
+			sums[i][j] /= n;
+  printf(1, "\n\nPriority 3:\nAverage ready time: %d\nAverage running time: %d\nAverage sleeping time: %d\nAverage turnaround time: %d\n\n\n", sums[0][0], sums[0][1], sums[0][2], sums[0][0] + sums[0][1] + sums[0][2]);
+	printf(1, "Priority 2:\nAverage ready time: %d\nAverage running time: %d\nAverage sleeping time: %d\nAverage turnaround time: %d\n\n\n", sums[1][0], sums[1][1], sums[1][2], sums[1][0] + sums[1][1] + sums[1][2]);
+	printf(1, "Priority 1:\nAverage ready time: %d\nAverage running time: %d\nAverage sleeping time: %d\nAverage turnaround time: %d\n\n\n", sums[2][0], sums[2][1], sums[2][2], sums[2][0] + sums[2][1] + sums[2][2]);
+	exit();
+}
diff --git a/TRICKS b/TRICKS
old mode 100644
new mode 100755
diff --git a/asm.h b/asm.h
old mode 100644
new mode 100755
diff --git a/bio.c b/bio.c
old mode 100644
new mode 100755
diff --git a/bootasm.S b/bootasm.S
old mode 100644
new mode 100755
diff --git a/bootmain.c b/bootmain.c
old mode 100644
new mode 100755
diff --git a/buf.h b/buf.h
old mode 100644
new mode 100755
diff --git a/cat.c b/cat.c
old mode 100644
new mode 100755
diff --git a/console.c b/console.c
old mode 100644
new mode 100755
index a280d2b..1cc1136
--- a/console.c
+++ b/console.c
@@ -1,7 +1,7 @@
 // Console input and output.
 // Input is from the keyboard or serial port.
 // Output is written to the screen and serial port.
-
+#include "console.h"
 #include "types.h"
 #include "defs.h"
 #include "param.h"
@@ -124,8 +124,7 @@ panic(char *s)
 }
 
 //PAGEBREAK: 50
-#define BACKSPACE 0x100
-#define CRTPORT 0x3d4
+
 static ushort *crt = (ushort*)P2V(0xb8000);  // CGA memory
 
 static void
@@ -139,13 +138,19 @@ cgaputc(int c)
   outb(CRTPORT, 15);
   pos |= inb(CRTPORT+1);
 
-  if(c == '\n')
-    pos += 80 - pos%80;
-  else if(c == BACKSPACE){
-    if(pos > 0) --pos;
-  } else
-    crt[pos++] = (c&0xff) | 0x0700;  // black on white
-
+  switch(c) {
+    case '\n':
+      pos += 80 - pos%80;
+      break;
+    case BACKSPACE:
+      if(pos > 0) --pos;
+      break;
+    case LEFT_ARROW:
+      if(pos > 0) --pos;
+      break;
+    default:
+      crt[pos++] = (c&0xff) | 0x0700;  // black on white
+  }
   if(pos < 0 || pos > 25*80)
     panic("pos under/overflow");
 
@@ -159,9 +164,11 @@ cgaputc(int c)
   outb(CRTPORT+1, pos>>8);
   outb(CRTPORT, 15);
   outb(CRTPORT+1, pos);
-  crt[pos] = ' ' | 0x0700;
+    if (c == BACKSPACE)
+    crt[pos] = ' ' | 0x0700;
 }
 
+
 void
 consputc(int c)
 {
@@ -171,60 +178,216 @@ consputc(int c)
       ;
   }
 
-  if(c == BACKSPACE){
-    uartputc('\b'); uartputc(' '); uartputc('\b');
-  } else
-    uartputc(c);
-  cgaputc(c);
+  switch (c) {
+    case BACKSPACE:
+      uartputc('\b'); uartputc(' '); uartputc('\b');
+      break;
+    case LEFT_ARROW:
+      uartputc('\b');
+      break;
+    default:
+      uartputc(c);
+  }
+  // cgaputc prints to QEMU's terminal
+    cgaputc(c);
 }
 
-#define INPUT_BUF 128
 struct {
   char buf[INPUT_BUF];
   uint r;  // Read index
   uint w;  // Write index
   uint e;  // Edit index
+  uint rightmost;
 } input;
 
+char charsToBeMoved[INPUT_BUF];  
+
+
+struct {
+  char bufferArr[MAX_HISTORY][INPUT_BUF]; 
+  uint lengthsArr[MAX_HISTORY]; 
+  uint lastCommandIndex;  
+  int numOfCommmandsInMem; 
+  int currentHistory;
+} historyBufferArray;
+
+char oldBuf[INPUT_BUF];
+uint lengthOfOldBuf;
+
+char buf2[INPUT_BUF];
+
 #define C(x)  ((x)-'@')  // Control-x
 
+void copyCharsToBeMoved() {
+  uint n = input.rightmost - input.r;
+  uint i;
+  for (i = 0; i < n; i++)
+  charsToBeMoved[i] = input.buf[(input.e + i) % INPUT_BUF];
+}
+
+void shiftbufright() {
+  uint n = input.rightmost - input.e;
+  int i;
+  for (i = 0; i < n; i++) {
+    char c = charsToBeMoved[i];
+    input.buf[(input.e + i) % INPUT_BUF] = c;
+    consputc(c);
+  }
+  memset(charsToBeMoved, '\0', INPUT_BUF);
+  for (i = 0; i < n; i++) {
+    consputc(LEFT_ARROW);
+  }
+}
+
+void shiftbufleft() {
+  uint n = input.rightmost - input.e;
+  uint i;
+  consputc(LEFT_ARROW);
+  input.e--;
+  for (i = 0; i < n; i++) {
+    char c = input.buf[(input.e + i + 1) % INPUT_BUF];
+    input.buf[(input.e + i) % INPUT_BUF] = c;
+    consputc(c);
+  }
+  input.rightmost--;
+  consputc(' '); 
+  for (i = 0; i <= n; i++) {
+    consputc(LEFT_ARROW); 
+  }
+}
+
 void
 consoleintr(int (*getc)(void))
 {
   int c, doprocdump = 0;
-
+  uint tempIndex;
   acquire(&cons.lock);
   while((c = getc()) >= 0){
     switch(c){
     case C('P'):  // Process listing.
-      // procdump() locks cons.lock indirectly; invoke later
-      doprocdump = 1;
-      break;
-    case C('U'):  // Kill line.
-      while(input.e != input.w &&
-            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
-        input.e--;
-        consputc(BACKSPACE);
-      }
-      break;
-    case C('H'): case '\x7f':  // Backspace
-      if(input.e != input.w){
-        input.e--;
-        consputc(BACKSPACE);
-      }
-      break;
-    default:
-      if(c != 0 && input.e-input.r < INPUT_BUF){
-        c = (c == '\r') ? '\n' : c;
-        input.buf[input.e++ % INPUT_BUF] = c;
-        consputc(c);
-        if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
-          input.w = input.e;
-          wakeup(&input.r);
+        doprocdump = 1;   // procdump() locks cons.lock indirectly; invoke later
+        break;
+      case C('U'):  // Kill line.
+        if (input.rightmost > input.e) { // caret isn't at the end of the line
+          uint numtoshift = input.rightmost - input.e;
+          uint placestoshift = input.e - input.w;
+          uint i;
+          for (i = 0; i < placestoshift; i++) {
+            consputc(LEFT_ARROW);
+          }
+          memset(buf2, '\0', INPUT_BUF);
+          for (i = 0; i < numtoshift; i++) {
+            buf2[i] = input.buf[(input.w + i + placestoshift) % INPUT_BUF];
+          }
+          for (i = 0; i < numtoshift; i++) {
+            input.buf[(input.w + i) % INPUT_BUF] = buf2[i];
+          }
+          input.e -= placestoshift;
+          input.rightmost -= placestoshift;
+          for (i = 0; i < numtoshift; i++) { // repaint the chars
+            consputc(input.buf[(input.e + i) % INPUT_BUF]);
+          }
+          for (i = 0; i < placestoshift; i++) { // erase the leftover chars
+            consputc(' ');
+          }
+          for (i = 0; i < placestoshift + numtoshift; i++) { // move the caret back to the left
+            consputc(LEFT_ARROW);
+          }
         }
+        else { // caret is at the end of the line -                                       ( deleting everything from both screen and inputbuf)
+          while(input.e != input.w &&
+                input.buf[(input.e - 1) % INPUT_BUF] != '\n'){
+            input.e--;
+            input.rightmost--;
+            consputc(BACKSPACE);
+          }
+        }
+        break;
+      case C('H'): case '\x7f':  // Backspace
+        if (input.rightmost != input.e && input.e != input.w) { // caret isn't at the end of the line
+          shiftbufleft();
+          break;
+        }
+        if(input.e != input.w){ // caret is at the end of the line - deleting last char
+          input.e--;
+          input.rightmost--;
+          consputc(BACKSPACE);
+        }
+        break;
+      case LEFT_ARROW:
+        if (input.e != input.w) {
+          input.e--;
+          consputc(c);
+        }
+        break;
+      case RIGHT_ARROW:
+        if (input.e < input.rightmost) {
+          consputc(input.buf[input.e % INPUT_BUF]);
+          input.e++;
+        }
+        else if (input.e == input.rightmost){
+          consputc(' ');
+          consputc(LEFT_ARROW);
+        }
+        break;
+      case UP_ARROW:
+       if (historyBufferArray.currentHistory < historyBufferArray.numOfCommmandsInMem-1 ){ // current history means the oldest possible will be MAX_HISTORY-1
+          earaseCurrentLineOnScreen();
+          if (historyBufferArray.currentHistory == -1)
+              copyCharsToBeMovedToOldBuf();
+          earaseContentOnInputBuf();
+          historyBufferArray.currentHistory++;
+          tempIndex = (historyBufferArray.lastCommandIndex + historyBufferArray.currentHistory) %MAX_HISTORY;
+          copyBufferToScreen(historyBufferArray.bufferArr[ tempIndex]  , historyBufferArray.lengthsArr[tempIndex]);
+          copyBufferToInputBuf(historyBufferArray.bufferArr[ tempIndex]  , historyBufferArray.lengthsArr[tempIndex]);
+        }
+        break;
+      case DOWN_ARROW:
+        switch(historyBufferArray.currentHistory){
+          case -1:
+            //does nothing
+            break;
+          case 0: //get string from old buf
+            earaseCurrentLineOnScreen();
+            copyBufferToInputBuf(oldBuf, lengthOfOldBuf);
+            copyBufferToScreen(oldBuf, lengthOfOldBuf);
+            historyBufferArray.currentHistory--;
+            break;
+          default:
+            earaseCurrentLineOnScreen();
+            historyBufferArray.currentHistory--;
+            tempIndex = (historyBufferArray.lastCommandIndex + historyBufferArray.currentHistory)%MAX_HISTORY;
+            copyBufferToScreen(historyBufferArray.bufferArr[ tempIndex]  , historyBufferArray.lengthsArr[tempIndex]);
+            copyBufferToInputBuf(historyBufferArray.bufferArr[ tempIndex]  , historyBufferArray.lengthsArr[tempIndex]);
+            break;
+        }
+        break;
+      case '\n':
+      case '\r':
+          input.e = input.rightmost;
+      default:
+        if(c != 0 && input.e-input.r < INPUT_BUF){
+          c = (c == '\r') ? '\n' : c;
+          if (input.rightmost > input.e) { // caret isn't at the end of the line
+            copyCharsToBeMoved();
+            input.buf[input.e++ % INPUT_BUF] = c;
+            input.rightmost++;
+            consputc(c);
+            shiftbufright();
+          }
+          else {
+            input.buf[input.e++ % INPUT_BUF] = c;
+            input.rightmost = input.e - input.rightmost == 1 ? input.e : input.rightmost;
+            consputc(c);
+          }
+          if(c == '\n' || c == C('D') || input.rightmost == input.r + INPUT_BUF){
+            saveCommandInHistory();
+            input.w = input.rightmost;
+            wakeup(&input.r);
+          }
+        }
+        break;
       }
-      break;
-    }
   }
   release(&cons.lock);
   if(doprocdump) {
@@ -232,6 +395,74 @@ consoleintr(int (*getc)(void))
   }
 }
 
+void
+earaseCurrentLineOnScreen(void){
+    uint numToEarase = input.rightmost - input.r;
+    uint i;
+    for (i = 0; i < numToEarase; i++) {
+      consputc(BACKSPACE);
+    }
+}
+
+void
+copyCharsToBeMovedToOldBuf(void){
+    lengthOfOldBuf = input.rightmost - input.r;
+    uint i;
+    for (i = 0; i < lengthOfOldBuf; i++) {
+        oldBuf[i] = input.buf[(input.r+i)%INPUT_BUF];
+    }
+}
+
+void
+earaseContentOnInputBuf(){
+  input.rightmost = input.r;
+  input.e = input.r;
+}
+
+void
+copyBufferToScreen(char * bufToPrintOnScreen, uint length){
+  uint i;
+  for (i = 0; i < length; i++) {
+    consputc(bufToPrintOnScreen[i]);
+  }
+}
+
+void
+copyBufferToInputBuf(char * bufToSaveInInput, uint length){
+  uint i;
+  for (i = 0; i < length; i++) {
+    input.buf[(input.r+i)%INPUT_BUF] = bufToSaveInInput[i];
+  }
+  input.e = input.r+length;
+  input.rightmost = input.e;
+}
+
+void
+saveCommandInHistory(){
+  historyBufferArray.currentHistory= -1;//reseting the users history current viewed
+  if (historyBufferArray.numOfCommmandsInMem < MAX_HISTORY)
+    historyBufferArray.numOfCommmandsInMem++; //when we get to MAX_HISTORY commands in memory we keep on inserting to the array in a circular mution
+  uint l = input.rightmost-input.r -1;
+  historyBufferArray.lastCommandIndex = (historyBufferArray.lastCommandIndex - 1)%MAX_HISTORY;
+  historyBufferArray.lengthsArr[historyBufferArray.lastCommandIndex] = l;
+  uint i;
+  for (i = 0; i < l; i++) { //do not want to save in memory the last char '/n'
+    historyBufferArray.bufferArr[historyBufferArray.lastCommandIndex][i] =  input.buf[(input.r+i)%INPUT_BUF];
+  }
+
+}
+
+int history(char *buffer, int historyId) {
+  if (historyId < 0 || historyId > MAX_HISTORY - 1)
+    return -2;
+  if (historyId >= historyBufferArray.numOfCommmandsInMem )
+    return -1;
+  memset(buffer, '\0', INPUT_BUF);
+  int tempIndex = (historyBufferArray.lastCommandIndex + historyId) % MAX_HISTORY;
+  memmove(buffer, historyBufferArray.bufferArr[tempIndex], historyBufferArray.lengthsArr[tempIndex]);
+  return 0;
+}
+
 int
 consoleread(struct inode *ip, char *dst, int n)
 {
@@ -295,5 +526,7 @@ consoleinit(void)
   cons.locking = 1;
 
   ioapicenable(IRQ_KBD, 0);
+  historyBufferArray.numOfCommmandsInMem=0;
+  historyBufferArray.lastCommandIndex=0;
 }
 
diff --git a/console.h b/console.h
new file mode 100755
index 0000000..bbb9af7
--- /dev/null
+++ b/console.h
@@ -0,0 +1,38 @@
+#define UP_ARROW 226
+#define DOWN_ARROW 227
+#define LEFT_ARROW 228
+#define RIGHT_ARROW 229
+
+#define BACKSPACE 0x100
+#define CRTPORT 0x3d4
+
+
+
+#include "types.h"
+
+
+
+void
+earaseCurrentLineOnScreen(void);
+
+
+void
+copyCharsToBeMovedToOldBuf(void);
+
+
+
+void
+earaseContentOnInputBuf();
+
+
+void
+copyBufferToScreen(char * bufToPrintOnScreen, uint length);
+
+
+void
+copyBufferToInputBuf(char * bufToSaveInInput, uint length);
+
+void
+saveCommandInHistory();
+
+int history(char *buffer, int historyId);
diff --git a/date.h b/date.h
old mode 100644
new mode 100755
diff --git a/defs.h b/defs.h
old mode 100644
new mode 100755
index 82fb982..854b970
--- a/defs.h
+++ b/defs.h
@@ -10,6 +10,9 @@ struct sleeplock;
 struct stat;
 struct superblock;
 
+#define INPUT_BUF 128
+#define MAX_HISTORY 16
+
 // bio.c
 void            binit(void);
 struct buf*     bread(uint, uint);
@@ -21,6 +24,7 @@ void            consoleinit(void);
 void            cprintf(char*, ...);
 void            consoleintr(int(*)(void));
 void            panic(char*) __attribute__((noreturn));
+int             history(char *, int );
 
 // exec.c
 int             exec(char*, char**);
@@ -118,8 +122,10 @@ void            setproc(struct proc*);
 void            sleep(void*, struct spinlock*);
 void            userinit(void);
 int             wait(void);
+int             wait2(int*, int*, int*);
 void            wakeup(void*);
 void            yield(void);
+int             set_prio(int);
 
 // swtch.S
 void            swtch(struct context**, struct context*);
diff --git a/echo.c b/echo.c
old mode 100644
new mode 100755
diff --git a/elf.h b/elf.h
old mode 100644
new mode 100755
diff --git a/entry.S b/entry.S
old mode 100644
new mode 100755
diff --git a/entryother.S b/entryother.S
old mode 100644
new mode 100755
diff --git a/exec.c b/exec.c
old mode 100644
new mode 100755
index b40134f..ab14851
--- a/exec.c
+++ b/exec.c
@@ -99,6 +99,10 @@ exec(char *path, char **argv)
   curproc->sz = sz;
   curproc->tf->eip = elf.entry;  // main
   curproc->tf->esp = sp;
+
+  #ifdef DML
+  curproc->priority = 2;
+  #endif
   switchuvm(curproc);
   freevm(oldpgdir);
   return 0;
diff --git a/fcntl.h b/fcntl.h
old mode 100644
new mode 100755
diff --git a/file.c b/file.c
old mode 100644
new mode 100755
diff --git a/file.h b/file.h
old mode 100644
new mode 100755
diff --git a/forktest.c b/forktest.c
old mode 100644
new mode 100755
diff --git a/fs.c b/fs.c
old mode 100644
new mode 100755
diff --git a/fs.h b/fs.h
old mode 100644
new mode 100755
diff --git a/gdbutil b/gdbutil
old mode 100644
new mode 100755
diff --git a/grep.c b/grep.c
old mode 100644
new mode 100755
diff --git a/ide.c b/ide.c
old mode 100644
new mode 100755
diff --git a/init.c b/init.c
old mode 100644
new mode 100755
diff --git a/initcode.S b/initcode.S
old mode 100644
new mode 100755
diff --git a/ioapic.c b/ioapic.c
old mode 100644
new mode 100755
diff --git a/kalloc.c b/kalloc.c
old mode 100644
new mode 100755
diff --git a/kbd.c b/kbd.c
old mode 100644
new mode 100755
diff --git a/kbd.h b/kbd.h
old mode 100644
new mode 100755
diff --git a/kernel.ld b/kernel.ld
old mode 100644
new mode 100755
diff --git a/kill.c b/kill.c
old mode 100644
new mode 100755
diff --git a/lapic.c b/lapic.c
old mode 100644
new mode 100755
diff --git a/ln.c b/ln.c
old mode 100644
new mode 100755
diff --git a/log.c b/log.c
old mode 100644
new mode 100755
diff --git a/ls.c b/ls.c
old mode 100644
new mode 100755
diff --git a/main.c b/main.c
old mode 100644
new mode 100755
diff --git a/memide.c b/memide.c
old mode 100644
new mode 100755
diff --git a/memlayout.h b/memlayout.h
old mode 100644
new mode 100755
diff --git a/mkdir.c b/mkdir.c
old mode 100644
new mode 100755
diff --git a/mkfs.c b/mkfs.c
old mode 100644
new mode 100755
diff --git a/mmu.h b/mmu.h
old mode 100644
new mode 100755
diff --git a/mp.c b/mp.c
old mode 100644
new mode 100755
diff --git a/mp.h b/mp.h
old mode 100644
new mode 100755
diff --git a/param.h b/param.h
old mode 100644
new mode 100755
index a7e90ef..bd56098
--- a/param.h
+++ b/param.h
@@ -11,4 +11,4 @@
 #define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
 #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
 #define FSSIZE       1000  // size of file system in blocks
-
+#define QUANTA 		 5
diff --git a/picirq.c b/picirq.c
old mode 100644
new mode 100755
diff --git a/pipe.c b/pipe.c
old mode 100644
new mode 100755
diff --git a/printf.c b/printf.c
old mode 100644
new mode 100755
diff --git a/proc.c b/proc.c
old mode 100644
new mode 100755
index 806b1b1..508d836
--- a/proc.c
+++ b/proc.c
@@ -6,6 +6,7 @@
 #include "x86.h"
 #include "proc.h"
 #include "spinlock.h"
+#define NULL 0
 
 struct {
   struct spinlock lock;
@@ -88,7 +89,18 @@ allocproc(void)
 found:
   p->state = EMBRYO;
   p->pid = nextpid++;
-
+  p->ctime = ticks;
+  p->retime = 0;
+  p->rutime = 0;
+  p->stime = 0;
+  p->fake[0] = '*';
+  p->fake[1] = '*';
+  p->fake[2] = '*';
+  p->fake[3] = '*';
+  p->fake[4] = '*';
+  p->fake[5] = '*';
+  p->fake[6] = '*';
+  p->fake[7] = '*';
   release(&ptable.lock);
 
   // Allocate kernel stack.
@@ -130,6 +142,8 @@ userinit(void)
     panic("userinit: out of memory?");
   inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
   p->sz = PGSIZE;
+  p->ctime = ticks;
+  p->priority = 2;
   memset(p->tf, 0, sizeof(*p->tf));
   p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
   p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
@@ -202,7 +216,8 @@ fork(void)
 
   // Clear %eax so that fork returns 0 in the child.
   np->tf->eax = 0;
-
+  struct proc *m = myproc();
+   np->priority = m->priority;  // set the new process's creation time
   for(i = 0; i < NOFILE; i++)
     if(curproc->ofile[i])
       np->ofile[i] = filedup(curproc->ofile[i]);
@@ -310,6 +325,140 @@ wait(void)
     sleep(curproc, &ptable.lock);  //DOC: wait-sleep
   }
 }
+int wait2(int *retime, int *rutime, int *stime) {
+   struct proc *p;
+   struct proc *m = myproc();
+   int havekids, pid;
+   acquire(&ptable.lock);
+   for (;;)
+   {
+     // Scan through table looking for zombie children.
+     havekids = 0;
+     for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+     {
+       if (p->parent != m)
+         continue;
+       havekids = 1;
+       if (p->state == ZOMBIE)
+       {
+         // Found one.
+         *retime = p->retime;
+         *rutime = p->rutime;
+         *stime = p->stime;
+         pid = p->pid;
+         kfree(p->kstack);
+         p->kstack = 0;
+         freevm(p->pgdir);
+         p->state = UNUSED;
+         p->pid = 0;
+         p->parent = 0;
+         p->name[0] = 0;
+         p->killed = 0;
+         p->ctime = 0;
+         p->retime = 0;
+         p->rutime = 0;
+         p->stime = 0;
+         p->priority = 0;
+         release(&ptable.lock);
+         return pid;
+       }
+     }
+
+     // No point waiting if we don't have any children.
+     if (!havekids || m->killed)
+     {
+       release(&ptable.lock);
+       return -1;
+     }
+
+     // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+     sleep(m, &ptable.lock); //DOC: wait-sleep
+  }
+}
+
+#ifdef SML
+/*
+  this method will find the next process to run
+*/
+struct proc* findreadyprocess(int *index1, int *index2, int *index3, uint *priority) {
+  int i;
+  struct proc* proc2;
+notfound:
+  for (i = 0; i < NPROC; i++) {
+    switch(*priority) {
+      case 1:
+        proc2 = &ptable.proc[(*index1 + i) % NPROC];
+        if (proc2->state == RUNNABLE && proc2->priority == *priority) {
+          *index1 = (*index1 + 1 + i) % NPROC;
+          return proc2; // found a runnable process with appropriate priority
+        }
+      case 2:
+        proc2 = &ptable.proc[(*index2 + i) % NPROC];
+        if (proc2->state == RUNNABLE && proc2->priority == *priority) {
+          *index2 = (*index2 + 1 + i) % NPROC;
+          return proc2; // found a runnable process with appropriate priority
+        }
+      case 3:
+        proc2 = &ptable.proc[(*index3 + i) % NPROC];
+        if (proc2->state == RUNNABLE && proc2->priority == *priority){
+          *index3 = (*index3 + 1 + i) % NPROC;
+          return proc2; // found a runnable process with appropriate priority
+        }
+    }
+  }
+  if (*priority == 1) {//did not find any process on any of the prorities
+    *priority = 3;
+    return 0;
+  }
+  else {
+    *priority -= 1; //will try to find a process at a lower priority
+    goto notfound;
+  }
+  return 0;
+}
+#endif
+
+#ifdef DML
+/*
+  this method will find the next process to run
+*/
+struct proc* findreadyprocess(int *index1, int *index2, int *index3, uint *priority) {
+  int i;
+  struct proc* proc2;
+notfound:
+  for (i = 0; i < NPROC; i++) {
+    switch(*priority) {
+      case 1:
+        proc2 = &ptable.proc[(*index1 + i) % NPROC];
+        if (proc2->state == RUNNABLE && proc2->priority == *priority) {
+          *index1 = (*index1 + 1 + i) % NPROC;
+          return proc2; // found a runnable process with appropriate priority
+        }
+      case 2:
+        proc2 = &ptable.proc[(*index2 + i) % NPROC];
+        if (proc2->state == RUNNABLE && proc2->priority == *priority) {
+          *index2 = (*index2 + 1 + i) % NPROC;
+          return proc2; // found a runnable process with appropriate priority
+        }
+      case 3:
+        proc2 = &ptable.proc[(*index3 + i) % NPROC];
+        if (proc2->state == RUNNABLE && proc2->priority == *priority){
+          *index3 = (*index3 + 1 + i) % NPROC;
+          return proc2; // found a runnable process with appropriate priority
+        }
+    }
+  }
+  if (*priority == 1) {//did not find any process on any of the prorities
+    *priority = 3;
+    return 0;
+  }
+  else {
+    *priority -= 1; //will try to find a process at a lower priority
+    goto notfound;
+  }
+  return 0;
+}
+#endif
 
 //PAGEBREAK: 42
 // Per-CPU process scheduler.
@@ -325,6 +474,15 @@ scheduler(void)
   struct proc *p;
   struct cpu *c = mycpu();
   c->proc = 0;
+  int index1 = 0;
+  int index2 = 0;
+  int index3 = 0;
+  int x = index1;
+  index1 = x;
+  x = index2;
+  index2 = x;
+  x = index3;
+  index3 = x;
   
   for(;;){
     // Enable interrupts on this processor.
@@ -332,6 +490,7 @@ scheduler(void)
 
     // Loop over process table looking for process to run.
     acquire(&ptable.lock);
+     #ifdef DEFAULT
     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
       if(p->state != RUNNABLE)
         continue;
@@ -350,6 +509,97 @@ scheduler(void)
       // It should have changed its p->state before coming back.
       c->proc = 0;
     }
+    #else
+
+#ifdef FCFS
+
+    struct proc *minP = NULL;
+
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+
+    {
+
+      if (p->state == RUNNABLE)
+
+      {
+
+        if (minP != NULL)
+
+        {
+
+          if (p->ctime < minP->ctime)
+
+            minP = p;
+
+        }
+
+        else
+
+          minP = p;
+
+      }
+
+    }
+
+    if (minP != NULL)
+
+    {
+
+      p = minP; //the process with the smallest creation time
+
+      c->proc = p;
+
+      switchuvm(p);
+
+      p->state = RUNNING;
+
+      swtch(&(c->scheduler), p->context);
+
+      switchkvm();
+
+      // Process is done running for now.
+
+      // It should have changed its p->state before coming back.
+
+      c->proc = 0;
+
+    }
+    #else
+
+    #ifdef SML
+    uint priority = 3;
+    p = findreadyprocess(&index1, &index2, &index3, &priority);
+    if (p == 0) {
+      release(&ptable.lock);
+      continue;
+    }
+    c->proc = p;
+    switchuvm(p);
+    p->state = RUNNING;
+    swtch(&(c->scheduler), p->context);
+    switchkvm();
+    c->proc = 0;
+    #else
+
+    #ifdef DML
+    uint priority = 3;
+    p = findreadyprocess(&index1, &index2, &index3, &priority);
+    if (p == 0) {
+      release(&ptable.lock);
+      continue;
+    }
+    c->proc = p;
+    switchuvm(p);
+    p->state = RUNNING;
+    p->tickcounter = 0;
+    swtch(&(c->scheduler), p->context);
+    switchkvm();
+    c->proc = 0;
+    #endif
+    #endif
+    #endif
+    #endif
+
     release(&ptable.lock);
 
   }
@@ -460,8 +710,12 @@ wakeup1(void *chan)
   struct proc *p;
 
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == SLEEPING && p->chan == chan)
+     if(p->state == SLEEPING && p->chan == chan) {
       p->state = RUNNABLE;
+      #ifdef DML
+      p->priority = 3; // relevant for DML - process waited for I\O, and now it's ready to run again
+      #endif
+    }
 }
 
 // Wake up all processes sleeping on chan.
@@ -532,3 +786,49 @@ procdump(void)
     cprintf("\n");
   }
 }
+void updatestatistics() {
+  struct proc *p;
+  acquire(&ptable.lock);
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    switch(p->state) {
+      case SLEEPING:
+        p->stime++;
+        break;
+      case RUNNABLE:
+        p->retime++;
+        break;
+      case RUNNING:
+        p->rutime++;
+        break;
+      default:
+        ;
+    }
+  }
+  release(&ptable.lock);
+}
+
+int set_prio(int priority) {
+  if (priority < 1 || priority > 3)
+    return -1;
+  acquire(&ptable.lock);
+  struct proc *m = myproc();
+  m->priority = priority;
+  release(&ptable.lock);
+  return 0;
+}
+
+void decpriority(void) {
+  struct proc *m = myproc();
+  // acquire(&ptable.lock);
+  m->priority = m->priority == 1 ? 1 : m->priority - 1;
+  // release(&ptable.lock);
+}
+
+int inctickcounter() {
+  int res;
+  struct proc *m = myproc();
+  acquire(&ptable.lock);
+  res = ++m->tickcounter;
+  release(&ptable.lock);
+  return res;
+}
diff --git a/proc.h b/proc.h
old mode 100644
new mode 100755
index 1647114..e45d7ef
--- a/proc.h
+++ b/proc.h
@@ -1,13 +1,14 @@
 // Per-CPU state
-struct cpu {
-  uchar apicid;                // Local APIC ID
-  struct context *scheduler;   // swtch() here to enter scheduler
-  struct taskstate ts;         // Used by x86 to find stack for interrupt
-  struct segdesc gdt[NSEGS];   // x86 global descriptor table
-  volatile uint started;       // Has the CPU started?
-  int ncli;                    // Depth of pushcli nesting.
-  int intena;                  // Were interrupts enabled before pushcli?
-  struct proc *proc;           // The process running on this cpu or null
+struct cpu
+{
+  uchar apicid;              // Local APIC ID
+  struct context *scheduler; // swtch() here to enter scheduler
+  struct taskstate ts;       // Used by x86 to find stack for interrupt
+  struct segdesc gdt[NSEGS]; // x86 global descriptor table
+  volatile uint started;     // Has the CPU started?
+  int ncli;                  // Depth of pushcli nesting.
+  int intena;                // Were interrupts enabled before pushcli?
+  struct proc *proc;         // The process running on this cpu or null
 };
 
 extern struct cpu cpus[NCPU];
@@ -24,7 +25,8 @@ extern int ncpu;
 // The layout of the context matches the layout of the stack in swtch.S
 // at the "Switch stacks" comment. Switch doesn't save eip explicitly,
 // but it is on the stack and allocproc() manipulates it.
-struct context {
+struct context
+{
   uint edi;
   uint esi;
   uint ebx;
@@ -32,23 +34,40 @@ struct context {
   uint eip;
 };
 
-enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
+enum procstate
+{
+  UNUSED,
+  EMBRYO,
+  SLEEPING,
+  RUNNABLE,
+  RUNNING,
+  ZOMBIE
+};
 
 // Per-process state
-struct proc {
-  uint sz;                     // Size of process memory (bytes)
-  pde_t* pgdir;                // Page table
-  char *kstack;                // Bottom of kernel stack for this process
-  enum procstate state;        // Process state
-  int pid;                     // Process ID
-  struct proc *parent;         // Parent process
-  struct trapframe *tf;        // Trap frame for current syscall
-  struct context *context;     // swtch() here to run process
-  void *chan;                  // If non-zero, sleeping on chan
-  int killed;                  // If non-zero, have been killed
-  struct file *ofile[NOFILE];  // Open files
-  struct inode *cwd;           // Current directory
-  char name[16];               // Process name (debugging)
+struct proc
+{
+  char name[16];              // Process name (debugging)
+  int pid;                    // Process ID
+  uint sz;                    // Size of process memory (bytes)
+  pde_t *pgdir;               // Page table
+  char *kstack;               // Bottom of kernel stack for this process
+  enum procstate state;       // Process state
+  struct proc *parent;        // Parent process
+  struct trapframe *tf;       // Trap frame for current syscall
+  struct context *context;    // swtch() here to run process
+  void *chan;                 // If non-zero, sleeping on chan
+  int killed;                 // If non-zero, have been killed
+  struct file *ofile[NOFILE]; // Open files
+  struct inode *cwd;          // Current directory
+
+  uint ctime; // Process creation time
+  int stime;  //process SLEEPING time
+  int retime; //process READY(RUNNABLE) time
+  int rutime;
+  int priority;
+  int tickcounter;
+  char fake[8];
 };
 
 // Process memory is laid out contiguously, low addresses first:
@@ -56,3 +75,4 @@ struct proc {
 //   original data and bss
 //   fixed-size stack
 //   expandable heap
+void updatestatistics();
\ No newline at end of file
diff --git a/rm.c b/rm.c
old mode 100644
new mode 100755
diff --git a/runoff.list b/runoff.list
old mode 100644
new mode 100755
diff --git a/runoff.spec b/runoff.spec
old mode 100644
new mode 100755
diff --git a/sanity.c b/sanity.c
new file mode 100755
index 0000000..e614911
--- /dev/null
+++ b/sanity.c
@@ -0,0 +1,112 @@
+#include "types.h"
+#include "user.h"
+
+int fact(int a){
+	if(a<=3)return 1;
+	return fact(a-1)*fact(a-2)*fact(a-3);
+}
+
+int main(int argc, char *argv[])
+{
+    if (argc != 2)
+    {
+        printf(1, "Usage: sanity <n>\n");
+        exit();
+    }
+
+    int i, j = 0, k, n;
+    int retime, rutime, stime;
+
+    int sums[3][3];
+    for (i = 0; i < 3; i++)
+    {
+        for (j = 0; j < 3; j++)
+            sums[i][j] = 0;
+    }
+
+    n = atoi(argv[1]);
+    i = n; //unimportant
+    int pid;
+    for (i = 0; i < 3 * n; i++)
+    {
+        j = i % 3;
+        pid = fork();
+        if (pid == 0)
+        {                           //child
+            j = (getpid() - 4) % 3; // ensures independence from the first son's pid when gathering the results in the second part of the program
+            switch (j)
+            {
+            case 0: //CPU‐bound process (CPU):
+          
+                for (k = 0; k < 100; k++)
+                {
+             
+                    for (j = 0; j < 1000000; j++)
+                    {
+                        fact(3);
+                    }
+                }
+                break;
+            case 1: //short tasks based CPU‐bound process (S‐CPU):
+            //int dummy=0;
+                for (k = 0; k < 100; k++)
+                {
+
+                
+                    for (j = 0; j < 1000000; j++)
+                    {
+                        fact(3);
+                    }
+                    yield();
+                }
+                break;
+            case 2: // simulate I/O bound process (IO)
+                for (k = 0; k < 100; k++)
+                {
+                    sleep(1);
+                }
+                break;
+            }
+            exit(); // children exit here
+        }
+        continue; // father continues to spawn the next child
+    }
+    for (i = 0; i < 3 * n; i++)
+    {
+        pid = wait2(&retime, &rutime, &stime);
+        int res = (pid - 4) % 3; // correlates to j in the dispatching loop
+        switch (res)
+        {
+        case 0: // CPU bound processes
+            printf(1, "CPU-bound, pid: %d, ready: %d, running: %d, sleeping: %d, turnaround: %d\n", pid, retime, rutime, stime, retime + rutime + stime);
+            sums[0][0] += retime;
+            sums[0][1] += rutime;
+            sums[0][2] += stime;
+            break;
+        case 1: // CPU bound processes, short tasks
+            printf(1, "CPU-S bound, pid: %d, ready: %d, running: %d, sleeping: %d, turnaround: %d\n", pid, retime, rutime, stime, retime + rutime + stime);
+            sums[1][0] += retime;
+            sums[1][1] += rutime;
+            sums[1][2] += stime;
+            break;
+        case 2: // simulating I/O bound processes
+            printf(1, "I/O bound, pid: %d, ready: %d, running: %d, sleeping: %d, turnaround: %d\n", pid, retime, rutime, stime, retime + rutime + stime);
+            sums[2][0] += retime;
+            sums[2][1] += rutime;
+            sums[2][2] += stime;
+            break;
+        }
+    }
+    for (i = 0; i < 3; i++)
+    {
+        for (j = 0; j < 3; j++)
+        {
+            sums[i][j] /= n;
+        }
+    }
+
+    printf(1, "\n\nCPU bound:\nAverage ready time: %d\nAverage running time: %d\nAverage sleeping time: %d\nAverage turnaround time: %d\n\n\n", sums[0][0], sums[0][1], sums[0][2], sums[0][0] + sums[0][1] + sums[0][2]);
+    printf(1, "CPU-S bound:\nAverage ready time: %d\nAverage running time: %d\nAverage sleeping time: %d\nAverage turnaround time: %d\n\n\n", sums[1][0], sums[1][1], sums[1][2], sums[1][0] + sums[1][1] + sums[1][2]);
+    printf(1, "I/O bound:\nAverage ready time: %d\nAverage running time: %d\nAverage sleeping time: %d\nAverage turnaround time: %d\n\n\n", sums[2][0], sums[2][1], sums[2][2], sums[2][0] + sums[2][1] + sums[2][2]);
+    exit();
+}
diff --git a/sh.c b/sh.c
old mode 100644
new mode 100755
index 054bab9..226fe40
--- a/sh.c
+++ b/sh.c
@@ -5,25 +5,28 @@
 #include "fcntl.h"
 
 // Parsed command representation
-#define EXEC  1
+#define EXEC 1
 #define REDIR 2
-#define PIPE  3
-#define LIST  4
-#define BACK  5
+#define PIPE 3
+#define LIST 4
+#define BACK 5
 
 #define MAXARGS 10
 
-struct cmd {
+struct cmd
+{
   int type;
 };
 
-struct execcmd {
+struct execcmd
+{
   int type;
   char *argv[MAXARGS];
   char *eargv[MAXARGS];
 };
 
-struct redircmd {
+struct redircmd
+{
   int type;
   struct cmd *cmd;
   char *file;
@@ -32,30 +35,49 @@ struct redircmd {
   int fd;
 };
 
-struct pipecmd {
+struct pipecmd
+{
   int type;
   struct cmd *left;
   struct cmd *right;
 };
 
-struct listcmd {
+struct listcmd
+{
   int type;
   struct cmd *left;
   struct cmd *right;
 };
 
-struct backcmd {
+struct backcmd
+{
   int type;
   struct cmd *cmd;
 };
 
-int fork1(void);  // Fork but panics on failure.
-void panic(char*);
-struct cmd *parsecmd(char*);
+int fork1(void);
+void panic(char *);
+struct cmd *parsecmd(char *);
+char cmdFromHistory[INPUT_BUF];
+
+void history1()
+{
+  int i, count = 0;
+  for (i = 0; i < MAX_HISTORY; i++)
+  {
+    if (history(cmdFromHistory, MAX_HISTORY - i - 1) == 0)
+    { //this is the sys call
+      count++;
+      if (count < 10)
+        printf(1, " %d: %s\n", count, cmdFromHistory);
+      else
+        printf(1, "%d: %s\n", count, cmdFromHistory);
+    }
+  }
+}
 
 // Execute cmd.  Never returns.
-void
-runcmd(struct cmd *cmd)
+void runcmd(struct cmd *cmd)
 {
   int p[2];
   struct backcmd *bcmd;
@@ -64,25 +86,27 @@ runcmd(struct cmd *cmd)
   struct pipecmd *pcmd;
   struct redircmd *rcmd;
 
-  if(cmd == 0)
+  if (cmd == 0)
     exit();
 
-  switch(cmd->type){
+  switch (cmd->type)
+  {
   default:
     panic("runcmd");
 
   case EXEC:
-    ecmd = (struct execcmd*)cmd;
-    if(ecmd->argv[0] == 0)
+    ecmd = (struct execcmd *)cmd;
+    if (ecmd->argv[0] == 0)
       exit();
     exec(ecmd->argv[0], ecmd->argv);
     printf(2, "exec %s failed\n", ecmd->argv[0]);
     break;
 
   case REDIR:
-    rcmd = (struct redircmd*)cmd;
+    rcmd = (struct redircmd *)cmd;
     close(rcmd->fd);
-    if(open(rcmd->file, rcmd->mode) < 0){
+    if (open(rcmd->file, rcmd->mode) < 0)
+    {
       printf(2, "open %s failed\n", rcmd->file);
       exit();
     }
@@ -90,25 +114,27 @@ runcmd(struct cmd *cmd)
     break;
 
   case LIST:
-    lcmd = (struct listcmd*)cmd;
-    if(fork1() == 0)
+    lcmd = (struct listcmd *)cmd;
+    if (fork1() == 0)
       runcmd(lcmd->left);
     wait();
     runcmd(lcmd->right);
     break;
 
   case PIPE:
-    pcmd = (struct pipecmd*)cmd;
-    if(pipe(p) < 0)
+    pcmd = (struct pipecmd *)cmd;
+    if (pipe(p) < 0)
       panic("pipe");
-    if(fork1() == 0){
+    if (fork1() == 0)
+    {
       close(1);
       dup(p[1]);
       close(p[0]);
       close(p[1]);
       runcmd(pcmd->left);
     }
-    if(fork1() == 0){
+    if (fork1() == 0)
+    {
       close(0);
       dup(p[0]);
       close(p[0]);
@@ -122,69 +148,101 @@ runcmd(struct cmd *cmd)
     break;
 
   case BACK:
-    bcmd = (struct backcmd*)cmd;
-    if(fork1() == 0)
+    bcmd = (struct backcmd *)cmd;
+    if (fork1() == 0)
       runcmd(bcmd->cmd);
     break;
   }
   exit();
 }
 
-int
-getcmd(char *buf, int nbuf)
+int getcmd(char *buf, int nbuf)
 {
   printf(2, "$ ");
   memset(buf, 0, nbuf);
   gets(buf, nbuf);
-  if(buf[0] == 0) // EOF
+  if (buf[0] == 0) // EOF
     return -1;
   return 0;
 }
 
-int
-main(void)
+int main(void)
 {
-  static char buf[100];
+  printf(1, "Selected scheduling policy: ");
+#ifdef DEFAULT
+  printf(1, "default\n");
+#else
+#ifdef FCFS
+  printf(1, "FCFS\n");
+#else
+#ifdef SML
+  printf(1, "SML\n");
+#else
+#ifdef DML
+  printf(1, "DML\n");
+#endif
+#endif
+#endif
+#endif
+
+  static char buf[INPUT_BUF];
   int fd;
-
+  // int retime, rutime, stime,pid;
   // Ensure that three file descriptors are open.
-  while((fd = open("console", O_RDWR)) >= 0){
-    if(fd >= 3){
+  while ((fd = open("console", O_RDWR)) >= 0)
+  {
+    if (fd >= 3)
+    {
       close(fd);
       break;
     }
   }
 
   // Read and run input commands.
-  while(getcmd(buf, sizeof(buf)) >= 0){
-    if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
+  while (getcmd(buf, sizeof(buf)) >= 0)
+  {
+    if (buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' ')
+    {
       // Chdir must be called by the parent, not the child.
-      buf[strlen(buf)-1] = 0;  // chop \n
-      if(chdir(buf+3) < 0)
-        printf(2, "cannot cd %s\n", buf+3);
+      buf[strlen(buf) - 1] = 0; // chop \n
+      if (chdir(buf + 3) < 0)
+        printf(2, "cannot cd %s\n", buf + 3);
+      continue;
+    }
+    if (buf[0] == 'h' && buf[1] == 'i' && buf[2] == 's' && buf[3] == 't' && buf[4] == 'o' && buf[5] == 'r' && buf[6] == 'y' && buf[7] == '\n')
+    {
+      history1();
       continue;
     }
-    if(fork1() == 0)
+    if (buf[0] == 'g' && buf[1] == 'e' && buf[2] == 't' && buf[3] == 'p' && buf[4] == 'i' && buf[5] == 'd')
+    {
+      printf(1, "Process ID: %d\n", getpid());
+      continue;
+    }
+    if (fork1() == 0)
       runcmd(parsecmd(buf));
-    wait();
+    else
+    {
+      wait();
+      // pid = wait2(&retime, &rutime, &stime);
+      // printf(1, "pid:%d retime:%d rutime%d stime:%d\n", pid, retime, rutime, stime);
+    }
   }
   exit();
 }
 
-void
-panic(char *s)
+void panic(char *s)
 {
   printf(2, "%s\n", s);
   exit();
 }
 
-int
-fork1(void)
+int fork1(void)
 {
   int pid;
 
   pid = fork();
-  if(pid == -1)
+  if (pid == -1)
     panic("fork");
   return pid;
 }
@@ -192,7 +250,7 @@ fork1(void)
 //PAGEBREAK!
 // Constructors
 
-struct cmd*
+struct cmd *
 execcmd(void)
 {
   struct execcmd *cmd;
@@ -200,10 +258,10 @@ execcmd(void)
   cmd = malloc(sizeof(*cmd));
   memset(cmd, 0, sizeof(*cmd));
   cmd->type = EXEC;
-  return (struct cmd*)cmd;
+  return (struct cmd *)cmd;
 }
 
-struct cmd*
+struct cmd *
 redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
 {
   struct redircmd *cmd;
@@ -216,10 +274,10 @@ redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
   cmd->efile = efile;
   cmd->mode = mode;
   cmd->fd = fd;
-  return (struct cmd*)cmd;
+  return (struct cmd *)cmd;
 }
 
-struct cmd*
+struct cmd *
 pipecmd(struct cmd *left, struct cmd *right)
 {
   struct pipecmd *cmd;
@@ -229,10 +287,10 @@ pipecmd(struct cmd *left, struct cmd *right)
   cmd->type = PIPE;
   cmd->left = left;
   cmd->right = right;
-  return (struct cmd*)cmd;
+  return (struct cmd *)cmd;
 }
 
-struct cmd*
+struct cmd *
 listcmd(struct cmd *left, struct cmd *right)
 {
   struct listcmd *cmd;
@@ -242,10 +300,10 @@ listcmd(struct cmd *left, struct cmd *right)
   cmd->type = LIST;
   cmd->left = left;
   cmd->right = right;
-  return (struct cmd*)cmd;
+  return (struct cmd *)cmd;
 }
 
-struct cmd*
+struct cmd *
 backcmd(struct cmd *subcmd)
 {
   struct backcmd *cmd;
@@ -254,7 +312,7 @@ backcmd(struct cmd *subcmd)
   memset(cmd, 0, sizeof(*cmd));
   cmd->type = BACK;
   cmd->cmd = subcmd;
-  return (struct cmd*)cmd;
+  return (struct cmd *)cmd;
 }
 //PAGEBREAK!
 // Parsing
@@ -262,19 +320,19 @@ backcmd(struct cmd *subcmd)
 char whitespace[] = " \t\r\n\v";
 char symbols[] = "<|>&;()";
 
-int
-gettoken(char **ps, char *es, char **q, char **eq)
+int gettoken(char **ps, char *es, char **q, char **eq)
 {
   char *s;
   int ret;
 
   s = *ps;
-  while(s < es && strchr(whitespace, *s))
+  while (s < es && strchr(whitespace, *s))
     s++;
-  if(q)
+  if (q)
     *q = s;
   ret = *s;
-  switch(*s){
+  switch (*s)
+  {
   case 0:
     break;
   case '|':
@@ -287,44 +345,44 @@ gettoken(char **ps, char *es, char **q, char **eq)
     break;
   case '>':
     s++;
-    if(*s == '>'){
+    if (*s == '>')
+    {
       ret = '+';
       s++;
     }
     break;
   default:
     ret = 'a';
-    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
+    while (s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
       s++;
     break;
   }
-  if(eq)
+  if (eq)
     *eq = s;
 
-  while(s < es && strchr(whitespace, *s))
+  while (s < es && strchr(whitespace, *s))
     s++;
   *ps = s;
   return ret;
 }
 
-int
-peek(char **ps, char *es, char *toks)
+int peek(char **ps, char *es, char *toks)
 {
   char *s;
 
   s = *ps;
-  while(s < es && strchr(whitespace, *s))
+  while (s < es && strchr(whitespace, *s))
     s++;
   *ps = s;
   return *s && strchr(toks, *s);
 }
 
-struct cmd *parseline(char**, char*);
-struct cmd *parsepipe(char**, char*);
-struct cmd *parseexec(char**, char*);
-struct cmd *nulterminate(struct cmd*);
+struct cmd *parseline(char **, char *);
+struct cmd *parsepipe(char **, char *);
+struct cmd *parseexec(char **, char *);
+struct cmd *nulterminate(struct cmd *);
 
-struct cmd*
+struct cmd *
 parsecmd(char *s)
 {
   char *es;
@@ -333,7 +391,8 @@ parsecmd(char *s)
   es = s + strlen(s);
   cmd = parseline(&s, es);
   peek(&s, es, "");
-  if(s != es){
+  if (s != es)
+  {
     printf(2, "leftovers: %s\n", s);
     panic("syntax");
   }
@@ -341,78 +400,83 @@ parsecmd(char *s)
   return cmd;
 }
 
-struct cmd*
+struct cmd *
 parseline(char **ps, char *es)
 {
   struct cmd *cmd;
 
   cmd = parsepipe(ps, es);
-  while(peek(ps, es, "&")){
+  while (peek(ps, es, "&"))
+  {
     gettoken(ps, es, 0, 0);
     cmd = backcmd(cmd);
   }
-  if(peek(ps, es, ";")){
+  if (peek(ps, es, ";"))
+  {
     gettoken(ps, es, 0, 0);
     cmd = listcmd(cmd, parseline(ps, es));
   }
   return cmd;
 }
 
-struct cmd*
+struct cmd *
 parsepipe(char **ps, char *es)
 {
   struct cmd *cmd;
 
   cmd = parseexec(ps, es);
-  if(peek(ps, es, "|")){
+  if (peek(ps, es, "|"))
+  {
     gettoken(ps, es, 0, 0);
     cmd = pipecmd(cmd, parsepipe(ps, es));
   }
   return cmd;
 }
 
-struct cmd*
+struct cmd *
 parseredirs(struct cmd *cmd, char **ps, char *es)
 {
   int tok;
   char *q, *eq;
 
-  while(peek(ps, es, "<>")){
+  while (peek(ps, es, "<>"))
+  {
     tok = gettoken(ps, es, 0, 0);
-    if(gettoken(ps, es, &q, &eq) != 'a')
+    if (gettoken(ps, es, &q, &eq) != 'a')
       panic("missing file for redirection");
-    switch(tok){
+    switch (tok)
+    {
     case '<':
       cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
       break;
     case '>':
-      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
+      cmd = redircmd(cmd, q, eq, O_WRONLY | O_CREATE, 1);
       break;
-    case '+':  // >>
-      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
+    case '+': // >>
+      cmd = redircmd(cmd, q, eq, O_WRONLY | O_CREATE, 1);
       break;
     }
   }
   return cmd;
 }
 
-struct cmd*
+struct cmd *
 parseblock(char **ps, char *es)
 {
   struct cmd *cmd;
 
-  if(!peek(ps, es, "("))
+  if (!peek(ps, es, "("))
     panic("parseblock");
   gettoken(ps, es, 0, 0);
   cmd = parseline(ps, es);
-  if(!peek(ps, es, ")"))
+  if (!peek(ps, es, ")"))
     panic("syntax - missing )");
   gettoken(ps, es, 0, 0);
   cmd = parseredirs(cmd, ps, es);
   return cmd;
 }
 
-struct cmd*
+struct cmd *
 parseexec(char **ps, char *es)
 {
   char *q, *eq;
@@ -420,23 +484,24 @@ parseexec(char **ps, char *es)
   struct execcmd *cmd;
   struct cmd *ret;
 
-  if(peek(ps, es, "("))
+  if (peek(ps, es, "("))
     return parseblock(ps, es);
 
   ret = execcmd();
-  cmd = (struct execcmd*)ret;
+  cmd = (struct execcmd *)ret;
 
   argc = 0;
   ret = parseredirs(ret, ps, es);
-  while(!peek(ps, es, "|)&;")){
-    if((tok=gettoken(ps, es, &q, &eq)) == 0)
+  while (!peek(ps, es, "|)&;"))
+  {
+    if ((tok = gettoken(ps, es, &q, &eq)) == 0)
       break;
-    if(tok != 'a')
+    if (tok != 'a')
       panic("syntax");
     cmd->argv[argc] = q;
     cmd->eargv[argc] = eq;
     argc++;
-    if(argc >= MAXARGS)
+    if (argc >= MAXARGS)
       panic("too many args");
     ret = parseredirs(ret, ps, es);
   }
@@ -446,7 +511,7 @@ parseexec(char **ps, char *es)
 }
 
 // NUL-terminate all the counted strings.
-struct cmd*
+struct cmd *
 nulterminate(struct cmd *cmd)
 {
   int i;
@@ -456,36 +521,37 @@ nulterminate(struct cmd *cmd)
   struct pipecmd *pcmd;
   struct redircmd *rcmd;
 
-  if(cmd == 0)
+  if (cmd == 0)
     return 0;
 
-  switch(cmd->type){
+  switch (cmd->type)
+  {
   case EXEC:
-    ecmd = (struct execcmd*)cmd;
-    for(i=0; ecmd->argv[i]; i++)
+    ecmd = (struct execcmd *)cmd;
+    for (i = 0; ecmd->argv[i]; i++)
       *ecmd->eargv[i] = 0;
     break;
 
   case REDIR:
-    rcmd = (struct redircmd*)cmd;
+    rcmd = (struct redircmd *)cmd;
     nulterminate(rcmd->cmd);
     *rcmd->efile = 0;
     break;
 
   case PIPE:
-    pcmd = (struct pipecmd*)cmd;
+    pcmd = (struct pipecmd *)cmd;
     nulterminate(pcmd->left);
     nulterminate(pcmd->right);
     break;
 
   case LIST:
-    lcmd = (struct listcmd*)cmd;
+    lcmd = (struct listcmd *)cmd;
     nulterminate(lcmd->left);
     nulterminate(lcmd->right);
     break;
 
   case BACK:
-    bcmd = (struct backcmd*)cmd;
+    bcmd = (struct backcmd *)cmd;
     nulterminate(bcmd->cmd);
     break;
   }
diff --git a/sleep1.p b/sleep1.p
old mode 100644
new mode 100755
diff --git a/sleeplock.c b/sleeplock.c
old mode 100644
new mode 100755
diff --git a/sleeplock.h b/sleeplock.h
old mode 100644
new mode 100755
diff --git a/spinlock.c b/spinlock.c
old mode 100644
new mode 100755
index 4020186..3f639bd
--- a/spinlock.c
+++ b/spinlock.c
@@ -9,8 +9,7 @@
 #include "proc.h"
 #include "spinlock.h"
 
-void
-initlock(struct spinlock *lk, char *name)
+void initlock(struct spinlock *lk, char *name)
 {
   lk->name = name;
   lk->locked = 0;
@@ -21,15 +20,14 @@ initlock(struct spinlock *lk, char *name)
 // Loops (spins) until the lock is acquired.
 // Holding a lock for a long time may cause
 // other CPUs to waste time spinning to acquire it.
-void
-acquire(struct spinlock *lk)
+void acquire(struct spinlock *lk)
 {
   pushcli(); // disable interrupts to avoid deadlock.
-  if(holding(lk))
+  if (holding(lk))
     panic("acquire");
 
   // The xchg is atomic.
-  while(xchg(&lk->locked, 1) != 0)
+  while (xchg(&lk->locked, 1) != 0)
     ;
 
   // Tell the C compiler and the processor to not move loads or stores
@@ -43,10 +41,9 @@ acquire(struct spinlock *lk)
 }
 
 // Release the lock.
-void
-release(struct spinlock *lk)
+void release(struct spinlock *lk)
 {
-  if(!holding(lk))
+  if (!holding(lk))
     panic("release");
 
   lk->pcs[0] = 0;
@@ -62,32 +59,33 @@ release(struct spinlock *lk)
   // Release the lock, equivalent to lk->locked = 0.
   // This code can't use a C assignment, since it might
   // not be atomic. A real OS would use C atomics here.
-  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+  asm volatile("movl $0, %0"
+               : "+m"(lk->locked)
+               :);
 
   popcli();
 }
 
 // Record the current call stack in pcs[] by following the %ebp chain.
-void
-getcallerpcs(void *v, uint pcs[])
+void getcallerpcs(void *v, uint pcs[])
 {
   uint *ebp;
   int i;
 
-  ebp = (uint*)v - 2;
-  for(i = 0; i < 10; i++){
-    if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
+  ebp = (uint *)v - 2;
+  for (i = 0; i < 10; i++)
+  {
+    if (ebp == 0 || ebp < (uint *)KERNBASE || ebp == (uint *)0xffffffff)
       break;
-    pcs[i] = ebp[1];     // saved %eip
-    ebp = (uint*)ebp[0]; // saved %ebp
+    pcs[i] = ebp[1];      // saved %eip
+    ebp = (uint *)ebp[0]; // saved %ebp
   }
-  for(; i < 10; i++)
+  for (; i < 10; i++)
     pcs[i] = 0;
 }
 
 // Check whether this cpu is holding the lock.
-int
-holding(struct spinlock *lock)
+int holding(struct spinlock *lock)
 {
   int r;
   pushcli();
@@ -96,31 +94,27 @@ holding(struct spinlock *lock)
   return r;
 }
 
-
 // Pushcli/popcli are like cli/sti except that they are matched:
 // it takes two popcli to undo two pushcli.  Also, if interrupts
 // are off, then pushcli, popcli leaves them off.
 
-void
-pushcli(void)
+void pushcli(void)
 {
   int eflags;
 
   eflags = readeflags();
   cli();
-  if(mycpu()->ncli == 0)
+  if (mycpu()->ncli == 0)
     mycpu()->intena = eflags & FL_IF;
   mycpu()->ncli += 1;
 }
 
-void
-popcli(void)
+void popcli(void)
 {
-  if(readeflags()&FL_IF)
+  if (readeflags() & FL_IF)
     panic("popcli - interruptible");
-  if(--mycpu()->ncli < 0)
+  if (--mycpu()->ncli < 0)
     panic("popcli");
-  if(mycpu()->ncli == 0 && mycpu()->intena)
+  if (mycpu()->ncli == 0 && mycpu()->intena)
     sti();
 }
-
diff --git a/spinlock.h b/spinlock.h
old mode 100644
new mode 100755
diff --git a/stat.h b/stat.h
old mode 100644
new mode 100755
diff --git a/stressfs.c b/stressfs.c
old mode 100644
new mode 100755
diff --git a/string.c b/string.c
old mode 100644
new mode 100755
diff --git a/swtch.S b/swtch.S
old mode 100644
new mode 100755
diff --git a/syscall.c b/syscall.c
old mode 100644
new mode 100755
index ee85261..1b7aa76
--- a/syscall.c
+++ b/syscall.c
@@ -103,6 +103,10 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_history(void);
+extern int sys_wait2(void);
+extern int sys_set_prio(void);
+extern int sys_yield(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +130,10 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_history] sys_history,
+[SYS_wait2]   sys_wait2,
+[SYS_set_prio] sys_set_prio,
+[SYS_yield]   sys_yield
 };
 
 void
diff --git a/syscall.h b/syscall.h
old mode 100644
new mode 100755
index bc5f356..9947f29
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,7 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_history  22
+#define SYS_wait2  23
+#define SYS_set_prio 24
+#define SYS_yield  25
\ No newline at end of file
diff --git a/sysfile.c b/sysfile.c
old mode 100644
new mode 100755
index bfe61b7..f0dafbf
--- a/sysfile.c
+++ b/sysfile.c
@@ -15,7 +15,7 @@
 #include "sleeplock.h"
 #include "file.h"
 #include "fcntl.h"
-
+#include "console.h"
 // Fetch the nth word-sized system call argument as a file descriptor
 // and return both the descriptor and the corresponding struct file.
 static int
diff --git a/sysproc.c b/sysproc.c
old mode 100644
new mode 100755
index 0686d29..f0630d6
--- a/sysproc.c
+++ b/sysproc.c
@@ -89,3 +89,32 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+
+int sys_history(void) {
+  char *buffer;
+  int historyId;
+  argptr(0, &buffer, 1);
+  argint(1, &historyId);
+  return history(buffer, historyId);
+}
+int sys_wait2(void) {
+  int *retime, *rutime, *stime;
+  if (argptr(0, (void*)&retime, sizeof(retime)) < 0)
+    return -1;
+  if (argptr(1, (void*)&rutime, sizeof(retime)) < 0)
+    return -1;
+  if (argptr(2, (void*)&stime, sizeof(stime)) < 0)
+    return -1;
+  return wait2(retime, rutime, stime);
+}
+int sys_set_prio(void) {
+  int priority;
+  argint(0, &priority);
+  return set_prio(priority);
+}
+
+int sys_yield(void) {
+  yield();
+  return 0;
+}
diff --git a/testing.c b/testing.c
new file mode 100755
index 0000000..3c980cb
--- /dev/null
+++ b/testing.c
@@ -0,0 +1,17 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int main(){
+    int retime, rutime, stime;
+printf(1,"before loop\n");
+    for(int i=0;i<5;i++){
+        fork();
+        printf(1,"before wait2\n");
+        int pid  = wait2(&retime, &rutime, &stime);
+        if(pid==-1) {printf(1,"no children \n");}
+        printf(1,"%d %d %d \n", retime, rutime, stime);
+    }
+    return 0;
+}
+
diff --git a/toc.ftr b/toc.ftr
old mode 100644
new mode 100755
diff --git a/toc.hdr b/toc.hdr
old mode 100644
new mode 100755
diff --git a/trap.c b/trap.c
old mode 100644
new mode 100755
index 41c66eb..b607ab1
--- a/trap.c
+++ b/trap.c
@@ -10,64 +10,79 @@
 
 // Interrupt descriptor table (shared by all CPUs).
 struct gatedesc idt[256];
-extern uint vectors[];  // in vectors.S: array of 256 entry pointers
+extern uint vectors[]; // in vectors.S: array of 256 entry pointers
 struct spinlock tickslock;
 uint ticks;
+extern int inctickcounter(void);
+extern void decpriority(void);
 
-void
-tvinit(void)
+void tvinit(void)
 {
   int i;
 
-  for(i = 0; i < 256; i++)
-    SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
-  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
+  for (i = 0; i < 256; i++)
+    SETGATE(idt[i], 0, SEG_KCODE << 3, vectors[i], 0);
+  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE << 3, vectors[T_SYSCALL], DPL_USER);
 
   initlock(&tickslock, "time");
 }
 
-void
-idtinit(void)
+void idtinit(void)
 {
   lidt(idt, sizeof(idt));
 }
 
 //PAGEBREAK: 41
-void
-trap(struct trapframe *tf)
+void trap(struct trapframe *tf)
 {
-  if(tf->trapno == T_SYSCALL){
-    if(myproc()->killed)
+  if (tf->trapno == T_SYSCALL)
+  {
+    if (myproc()->killed)
       exit();
     myproc()->tf = tf;
     syscall();
-    if(myproc()->killed)
+    if (myproc()->killed)
       exit();
     return;
   }
 
-  switch(tf->trapno){
+  switch (tf->trapno)
+  {
   case T_IRQ0 + IRQ_TIMER:
-    if(cpuid() == 0){
+    if (cpuid() == 0)
+    {
       acquire(&tickslock);
       ticks++;
+      updatestatistics();
       wakeup(&ticks);
       release(&tickslock);
     }
     lapiceoi();
     break;
   case T_IRQ0 + IRQ_IDE:
+#ifdef FCFS
+#else
+// resettickscycle();
+#endif
     ideintr();
     lapiceoi();
     break;
-  case T_IRQ0 + IRQ_IDE+1:
+  case T_IRQ0 + IRQ_IDE + 1:
     // Bochs generates spurious IDE1 interrupts.
     break;
   case T_IRQ0 + IRQ_KBD:
+#ifdef FCFS
+#else
+// resettickscycle();
+#endif
     kbdintr();
     lapiceoi();
     break;
   case T_IRQ0 + IRQ_COM1:
+#ifdef FCFS
+#else
+// resettickscycle();
+#endif
     uartintr();
     lapiceoi();
     break;
@@ -80,7 +95,8 @@ trap(struct trapframe *tf)
 
   //PAGEBREAK: 13
   default:
-    if(myproc() == 0 || (tf->cs&3) == 0){
+    if (myproc() == 0 || (tf->cs & 3) == 0)
+    {
       // In kernel, it must be our mistake.
       cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
               tf->trapno, cpuid(), tf->eip, rcr2());
@@ -97,16 +113,35 @@ trap(struct trapframe *tf)
   // Force process exit if it has been killed and is in user space.
   // (If it is still executing in the kernel, let it keep running
   // until it gets to the regular system call return.)
-  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+  if (myproc() && myproc()->killed && (tf->cs & 3) == DPL_USER)
     exit();
 
+#ifdef FCFS
+// do not yield
+#else
+
+#ifdef DML
+  struct proc *m = myproc();
   // Force process to give up CPU on clock tick.
   // If interrupts were on while locks held, would need to check nlock.
-  if(myproc() && myproc()->state == RUNNING &&
-     tf->trapno == T_IRQ0+IRQ_TIMER)
+  if (m && myproc()->state == RUNNING && tf->trapno == T_IRQ0 + IRQ_TIMER && inctickcounter() == QUANTA)
+  {
+    decpriority();
     yield();
+  }
+
+#else
+  struct proc *m = myproc();
+  // Force process to give up CPU on clock tick.
+  // If interrupts were on while locks held, would need to check nlock.
+  if (m && myproc()->state == RUNNING && tf->trapno == T_IRQ0 + IRQ_TIMER && inctickcounter() == QUANTA)
+  {
+    yield();
+  }
+#endif
+#endif
 
   // Check if the process has been killed since we yielded
-  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+  if (myproc() && myproc()->killed && (tf->cs & 3) == DPL_USER)
     exit();
 }
diff --git a/trapasm.S b/trapasm.S
old mode 100644
new mode 100755
diff --git a/traps.h b/traps.h
old mode 100644
new mode 100755
diff --git a/types.h b/types.h
old mode 100644
new mode 100755
index e4adf64..31c6c89
--- a/types.h
+++ b/types.h
@@ -2,3 +2,6 @@ typedef unsigned int   uint;
 typedef unsigned short ushort;
 typedef unsigned char  uchar;
 typedef uint pde_t;
+
+#define INPUT_BUF 128
+#define MAX_HISTORY 16
\ No newline at end of file
diff --git a/uart.c b/uart.c
old mode 100644
new mode 100755
diff --git a/ulib.c b/ulib.c
old mode 100644
new mode 100755
index 8e1e1a2..0122f9a
--- a/ulib.c
+++ b/ulib.c
@@ -55,7 +55,7 @@ gets(char *buf, int max)
   int i, cc;
   char c;
 
-  for(i=0; i+1 < max; ){
+  for(i=0; i < max; ){
     cc = read(0, &c, 1);
     if(cc < 1)
       break;
@@ -63,7 +63,10 @@ gets(char *buf, int max)
     if(c == '\n' || c == '\r')
       break;
   }
-  buf[i] = '\0';
+    if (i < max - 1)
+    buf[i] = '\0';
+  else
+    buf[max - 1] = '\0';
   return buf;
 }
 
diff --git a/umalloc.c b/umalloc.c
old mode 100644
new mode 100755
diff --git a/user.h b/user.h
old mode 100644
new mode 100755
index 4f99c52..8b7efcb
--- a/user.h
+++ b/user.h
@@ -23,6 +23,12 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int history(char*, int);
+int wait2(int*, int*, int*);
+#ifdef SML
+int set_prio(int);
+#endif
+int yield(void);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/usertests.c b/usertests.c
old mode 100644
new mode 100755
diff --git a/usys.S b/usys.S
old mode 100644
new mode 100755
index 8bfd8a1..e68bd85
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,7 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(history)
+SYSCALL(wait2)
+SYSCALL(set_prio)
+SYSCALL(yield)	
\ No newline at end of file
diff --git a/vm.c b/vm.c
old mode 100644
new mode 100755
diff --git a/wc.c b/wc.c
old mode 100644
new mode 100755
diff --git a/x86.h b/x86.h
old mode 100644
new mode 100755
diff --git a/zombie.c b/zombie.c
old mode 100644
new mode 100755
